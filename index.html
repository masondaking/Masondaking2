<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Masondaking's Profile</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    
    <!-- Custom Styles (Fonts, Colors, Animations) -->
    <style>
        /* Import the Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

        /* Custom "midnight purple" theme */
        :root {
            --bg-primary: #111827; /* gray-900 */
            --bg-secondary: #1F2937; /* gray-800 */
            --bg-card: #171E2A; /* Slightly darker than gray-800 */
            --accent: #a78bfa; /* violet-400 (softer purple) */
            --accent-dark: #7c3aed; /* violet-600 */
            --text-primary: #f3f4f6; /* gray-100 */
            --text-secondary: #9ca3af; /* gray-400 */
        }

        /* Starry background animation */
        @keyframes move-stars {
            from { background-position: 0 0; }
            to { background-position: -10000px 5000px; }
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
            overflow-x: hidden;
            background-color: #0c0a18; /* Very dark purple base */
            /* Simplified background: Just the nebula */
            background-image: radial-gradient(ellipse at center, rgba(49, 27, 109, 0.6) 0%, rgba(12, 10, 24, 0) 60%);
            background-repeat: no-repeat;
            background-size: 100% 100%;
            background-attachment: fixed;
            position: relative; 
            z-index: 1;
        }

        /* Re-added Starry Background using Pseudo-Elements (More reliable) */
        body::before, body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-repeat: repeat;
            background-attachment: fixed;
            z-index: -1;
            animation: move-stars 200s linear infinite;
        }
        /* Small stars */
        body::before {
            background-image: 
                radial-gradient(1px 1px at 20px 30px, white, rgba(255,255,255,0)),
                radial-gradient(1px 1px at 90px 40px, white, rgba(255,255,255,0)),
                radial-gradient(1.5px 1.5px at 160px 120px, white, rgba(255,255,255,0));
            background-size: 200px 200px;
        }
        /* Medium stars */
        body::after {
            background-image: 
                radial-gradient(1px 1px at 50px 120px, white, rgba(255,255,255,0)),
                radial-gradient(1px 1px at 110px 180px, white, rgba(255,255,255,0)),
                radial-gradient(1px 1px at 170px 140px, white, rgba(255,255,255,0));
            background-size: 300px 300px;
            animation-duration: 300s; /* Move at a different speed */
        }

        /* Fade in animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Main Profile Card Style */
        .profile-card {
            background-color: rgba(23, 30, 42, 0.9); /* var(--bg-card) with opacity */
            backdrop-filter: blur(12px); /* Glassmorphism effect */
            border: 1px solid var(--accent-dark);
            border-radius: 1.5rem; /* 24px */
            animation: fadeIn 0.6s ease-out forwards;
            animation-delay: 0.4s; /* Staggered animation delay */
            width: 100%;
            max-width: 400px; /* Made card slightly slimmer */
            overflow: hidden; /* To contain card elements */
            opacity: 0; /* Start hidden before animation */
            transition: transform 0.3s ease-out, box-shadow 0.3s ease-out; /* For mouse effect */
            /* Base shadow for the card */
            box-shadow: 0 0 25px rgba(124, 58, 237, 0.3);
        }
        
        /* New Konami Code Flip Animation */
        @keyframes card-flip {
            from {
                transform: perspective(1000px) rotateY(0deg) scale(1.03);
            }
            to {
                transform: perspective(1000px) rotateY(360deg) scale(1.03);
            }
        }
        .card-flip {
            animation: card-flip 1s ease-in-out;
        }


        /* Page content container */
        .page-content {
            display: none; /* Hidden by default */
            width: 100%;
            padding: 1.5rem;
            animation: fadeIn 0.5s ease-out;
        }
        .page-content.active {
            display: flex; /* Shown when active */
            flex-direction: column; /* Stack elements vertically */
            justify-content: center;
            align-items: center;
        }

        /* Profile picture style */
        @keyframes pulseGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(124, 58, 237, 0.5);
                border-color: var(--accent-dark);
            }
            50% {
                box-shadow: 0 0 30px rgba(167, 139, 250, 0.8);
                border-color: var(--accent);
            }
        }
        .profile-picture {
            border: 3px solid var(--accent-dark);
            width: 128px; /* 8rem */
            height: 128px; /* 8rem */
            animation: pulseGlow 2.5s ease-in-out infinite;
        }
        
        /* Skill Tag Style */
        .skill-tag {
            background-color: rgba(124, 58, 237, 0.1);
            color: var(--accent);
            border: 1px solid rgba(124, 58, 237, 0.3);
            font-weight: 500;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px; /* pill shape */
            font-size: 0.875rem; /* 14px */
            transition: all 0.2s ease;
            cursor: pointer; /* Show it's clickable */
            position: relative; /* Needed for tooltip positioning */
        }
        .skill-tag:hover {
            transform: scale(1.05);
            background-color: rgba(124, 58, 237, 0.2);
        }

        /* New Skill Tooltip Style */
        #skill-tooltip {
            position: absolute;
            background-color: rgba(40, 50, 70, 0.9); /* Glassy dark blue */
            backdrop-filter: blur(8px);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            border: 1px solid var(--accent);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 10;
            opacity: 0;
            transform: translateY(10px) scale(0.9);
            pointer-events: none;
            transition: all 0.2s ease-out;
            /* Positioned by JS */
        }
        #skill-tooltip::after {
            /* Triangle beak */
            content: '';
            position: absolute;
            bottom: -6px; /* Position at the bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 0; 
            height: 0; 
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid var(--accent);
        }
        #skill-tooltip.active {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        /* New Status Style */
        @keyframes pulseGreen {
            0%, 100% { 
                opacity: 1; 
                text-shadow: 0 0 10px #4ade80, 0 0 3px #4ade80;
            }
            50% { 
                opacity: 0.8; 
                text-shadow: 0 0 5px #4ade80;
            }
        }
        .status-online {
            color: #4ade80; /* green-400 */
            font-weight: 600;
            animation: pulseGreen 2s ease-in-out infinite;
        }

        /* New Status Styles for Discord */
        @keyframes pulseYellow {
            0%, 100% { opacity: 1; text-shadow: 0 0 10px #facc15, 0 0 3px #facc15; }
            50% { opacity: 0.8; text-shadow: 0 0 5px #facc15; }
        }
        .status-idle {
            color: #facc15; /* yellow-400 */
            font-weight: 600;
            animation: pulseYellow 2s ease-in-out infinite;
        }

        @keyframes pulseRedStatus {
             0%, 100% { opacity: 1; text-shadow: 0 0 10px #f87171, 0 0 3px #f87171; }
            50% { opacity: 0.8; text-shadow: 0 0 5px #f87171; }
        }
        .status-dnd {
            color: #f87171; /* red-400 */
            font-weight: 600;
            animation: pulseRedStatus 2s ease-in-out infinite;
        }
        .status-offline {
            color: #9ca3af; /* gray-400 */
            font-weight: 600;
        }
        /* End of New Status Styles */


        /* New "Cooking" Text Style */
        .cooking-text {
            opacity: 0; /* Start hidden */
            /* Removed animation, will be triggered by JS */
            transition: opacity 0.6s ease-out; /* Add transition for 'active' class */
        }
        .cooking-text.active {
            opacity: 1;
        }

        /* Style for new title shadow */
        .title-shadow {
            text-shadow: 0 2px 15px rgba(0,0,0,0.5);
        }

        /* "Click to Enter" Overlay */
        @keyframes pulseText {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.03);
                opacity: 0.9;
            }
        }
        #enter-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(12, 10, 24, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }
        .enter-text {
            color: white;
            font-size: 2rem;
            font-weight: 600;
            border: 2px solid white;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            animation: pulseText 2s ease-in-out infinite;
            transition: all 0.2s ease; /* Added transition */
        }
        .enter-text:hover {
            transform: scale(1.05);
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* New "Trick" Styles */
        @keyframes pulseRed {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
                opacity: 0.6;
            }
            50% {
                box-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
                opacity: 0.8;
            }
        }
        #trick-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 12px; /* Made smaller */
            height: 12px; /* Made smaller */
            background-color: red;
            border: none;
            border-radius: 9999px;
            cursor: pointer;
            z-index: 990;
            animation: pulseRed 2s ease-in-out infinite; /* Made slower */
            transition: all 0.2s ease;
            opacity: 0.6; /* Made less bright */
        }
        #trick-btn:hover {
            transform: scale(1.1);
        }

        /* Modal for the question */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal-backdrop.active {
            opacity: 1;
            pointer-events: all;
        }
        .modal-content {
            background-color: rgba(23, 30, 42, 0.9); /* Glassy background */
            border: 1px solid var(--accent-dark);
            box-shadow: 0 0 35px rgba(124, 58, 237, 0.5);
            border-radius: 0.75rem; /* 12px */
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        .modal-backdrop.active .modal-content {
            transform: scale(1);
        }

        /* Dangerous button hover */
        #what-btn {
            transition: all 0.2s ease; /* Ensure transition is defined */
        }
        #what-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(239, 68, 68, 0.7); /* red-500 glow */
        }

        /* Dark overlay for webcam */
        #dark-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #000000;
            z-index: 1001;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #webcam-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }
        @keyframes fadeInOutText {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.8; }
        }
        #spooky-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: white;
            font-weight: 600;
            text-shadow: 0 0 15px white;
            animation: fadeInOutText 4s ease-in-out infinite;
        }

        /* New "Spam Toast" Style */
        #spam-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%, 150%);
            background-color: var(--accent-dark);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 5px 20px rgba(124, 58, 237, 0.5);
            font-weight: 600;
            z-index: 999;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.21, 1.02, 0.73, 1); /* Bouncy ease */
        }
        #spam-toast.active {
            transform: translate(-50%, 0);
            opacity: 1;
        }

        /* New "Now Playing" Style */
        #now-playing {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: rgba(23, 30, 42, 0.9); /* Glassy background */
            backdrop-filter: blur(8px);
            border: 1px solid var(--accent-dark);
            box-shadow: 0 0 20px rgba(124, 58, 237, 0.3);
            border-radius: 0.75rem;
            padding: 0.75rem 1.25rem;
            z-index: 990;
            color: white;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease-out 0.5s; /* Delay fade in */
        }
        #now-playing.active {
            opacity: 1;
            transform: translateY(0);
        }
        #now-playing i {
            color: var(--accent);
        }
        /* New Play/Pause button */
        #play-pause-btn {
            background: none;
            border: none;
            color: var(--accent);
            cursor: pointer;
            padding: 0;
            margin-right: 0.5rem;
        }
        #play-pause-btn i {
            font-size: 1.75rem; /* 28px */
            transition: all 0.1s ease;
        }
        #play-pause-btn:hover i {
            color: white;
        }

        /* New "Now Playing" Sound Bar */
        .sound-bar {
            display: flex;
            align-items: flex-end;
            height: 16px;
            gap: 2px;
        }
        .sound-bar span {
            width: 3px;
            background-color: var(--accent);
            /* Paused state */
            height: 2px;
            transition: all 0.3s ease;
        }
        /* Running animation */
        .sound-bar.playing span {
            animation: sound-wave 1.2s ease-in-out infinite alternate;
        }
        .sound-bar.playing span:nth-child(1) { height: 4px; animation-delay: 0s; }
        .sound-bar.playing span:nth-child(2) { height: 10px; animation-delay: 0.2s; }
        .sound-bar.playing span:nth-child(3) { height: 16px; animation-delay: 0.4s; }
        .sound-bar.playing span:nth-child(4) { height: 7px; animation-delay: 0.6s; }
        
        @keyframes sound-wave {
            from { height: 2px; }
            to { height: 16px; }
        }

        /* New Mouse Trail Particle Style */
        .mouse-trail-particle {
            position: absolute;
            width: 6px; 
            height: 6px; 
            background-color: white; 
            border-radius: 50%;
            /* More reliable glow */
            box-shadow: 0 0 8px white, 0 0 12px var(--accent);
            pointer-events: none;
            z-index: 1000;
            opacity: 1;
            transition: all 1s ease-out; /* Default fade duration */
            /* Will be positioned by JS */
        }

        /* New Star Particle Style */
        .star-particle {
            position: absolute;
            width: 8px; 
            height: 8px; 
            background-color: white; /* Brighter base */
            border-radius: 50%;
            /* More reliable glow */
            box-shadow: 0 0 12px white, 0 0 20px var(--accent);
            pointer-events: none;
            z-index: 1000;
            opacity: 1;
            transition: all 2.5s ease-out; /* Slower fade duration */
            /* Will be positioned by JS */
        }

    </style>
</head>
<body class="text-gray-100">

    <!-- Click to Enter Overlay -->
    <div id="enter-overlay">
        <div class="enter-text">Click to Enter</div>
    </div>

    <!-- New "Trick" Button -->
    <button id="trick-btn"></button>

    <!-- Main Content Area (Centering Container) -->
    <div class="min-h-screen flex flex-col justify-center items-center p-4">
        
        <!-- Public Dashboard Page -->
        <main id="dashboard-page" class="page-content active">
            
            <!-- New "Cooking" Text -->
            <div class="text-center mb-6 cooking-text">
                <p id="cooking-text" class="text-white text-lg font-medium" style="text-shadow: 0 1px 10px rgba(255,255,255,0.3);"></p>
            </div>

            <!-- New Profile Card -->
            <div class="profile-card">
                <!-- Card Body -->
                <div class="p-8 text-center">
                    <!-- Profile Picture -->
                    <!-- This 'src' is now a fallback, JS will update it -->
                    <img src="./49acd725251af90a7ebac5f35a34c9cc.jpg" 
                         alt="Profile Avatar" 
                         class="rounded-full object-cover profile-picture mx-auto mt-6 mb-4"
                         onerror="this.src='https://placehold.co/128x128/D1C4E9/4527A0?text=PFP'; this.onerror=null;"
                         > <!-- Added onerror failsafe back -->
                    
                    <!-- Name & Title -->
                    <h1 class="text-3xl font-bold text-white mt-4 title-shadow">Masondaking</h1>
                    <p class="text-lg font-medium text-violet-400 title-shadow">
                        Creative Developer â€¢ <span id="status-text" class="status-online">Online</span>
                    </Example-A>
                    <!-- New element for game activity -->
                    <p id="game-activity" class="text-sm text-violet-200 title-shadow h-5 mt-1"></p>
                    
                    <!-- About Section -->
                    <div class="text-left mt-6">
                        <h2 class="font-semibold text-sm uppercase text-gray-400 tracking-wider mb-2">About</h2>
                        <p class="text-gray-300">
                            Developer of Dreamscibe (5K+ views).
                            Passionate about leading development and helping build great communities.
                        </p>
                    </div>

                    <!-- Skills Section -->
                    <div class="text-left mt-6">
                        <h2 class="font-semibold text-sm uppercase text-gray-400 tracking-wider mb-3">Skills</h2>
                        <div class="flex flex-wrap gap-2">
                            <span class="skill-tag" data-skill="Dreamscibe">Dreamscibe</span>
                            <span class="skill-tag" data-skill="Development">Development</span>
                            <span class="skill-tag" data-skill="UI/UX Design">UI/UX Design</span>
                        </div>
                    </div>

                </div>
            </div>
            
        </main>

    </div>

    <!-- Skill Tooltip (Hidden by default) -->
    <div id="skill-tooltip">This is a test</div>

    <!-- New Question Modal -->
    <div id="question-modal" class="modal-backdrop">
        <div class="modal-content text-center">
            <h2 class="text-2xl font-bold text-white mb-6">What's the worst thing ever?</h2>
            <div class="flex justify-center gap-4">
                <button id="leave-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-6 rounded-lg transition-all">Leave</button>
                <button id="what-btn" class="bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg shadow-red-600/50">Find Out</button>
            </div>
        </div>
    </div>

    <!-- New Dark Overlay for Webcam -->
    <div id="dark-overlay">
        <div id="spooky-text">Look at you.</div>
        <video id="webcam-feed" autoplay playsinline></video>
    </div>


    <!-- New Spam Toast Message -->
    <div id="spam-toast">
        Woah, take me out to dinner first!
    </div>

    <!-- Re-added "Now Playing" Box -->
    <div id="now-playing">
        <button id="play-pause-btn">
            <i class="ph-fill ph-play-circle"></i> <!-- ph-pause-circle -->
        </button>
        <div>
            <span class="text-sm text-gray-400">Now Playing</span>
            <p class="leading-tight">Fine China</p>
        </div>
        <!-- New Sound Bar -->
        <div class="sound-bar ml-auto">
            <span></span><span></span><span></span><span></span>
        </div>
    </div>

    <!-- Re-added Audio player -->
    <audio id="bg-music" src="./Fine China.mp3" loop></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const audio = document.getElementById('bg-music');
            const enterOverlay = document.getElementById('enter-overlay');

            // New "Trick" elements
            const trickBtn = document.getElementById('trick-btn');
            const questionModal = document.getElementById('question-modal');
            const leaveBtn = document.getElementById('leave-btn');
            const whatBtn = document.getElementById('what-btn');
            const darkOverlay = document.getElementById('dark-overlay');
            const webcamFeed = document.getElementById('webcam-feed');
            
            // New Spam Click elements
            const profilePicture = document.querySelector('.profile-picture');
            const spamToast = document.getElementById('spam-toast');
            let clickTimestamps = [];
            let toastTimeout = null;
            let spamCount = 0;

            // New Skill Tooltip elements
            const skillTooltip = document.getElementById('skill-tooltip');
            const skillTags = document.querySelectorAll('.skill-tag');
            const skillDescriptions = {
                'Dreamscibe': 'My main project - 5K+ views!',
                'Development': 'I love coding and building new things.',
                'UI/UX Design': 'Making things look good is half the fun.'
            };
            
            // New Discord Status elements
            const statusText = document.getElementById('status-text');
            const gameActivity = document.getElementById('game-activity');
            const YOUR_DISCORD_ID = '1338747411065208882';

            // New "Now Playing" elements
            const nowPlaying = document.getElementById('now-playing');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const playIcon = 'ph-play-circle';
            const pauseIcon = 'ph-pause-circle';
            const soundBar = document.querySelector('.sound-bar');

            // New Konami Code elements
            const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
            let konamiIndex = 0;
            
            // New Text Scramble element
            const scrambleElement = document.getElementById('cooking-text');
            const finalCookingText = "I'm cooking smth rn ðŸ™";
            
            // New Intro Animation flag
            let isIntroAnimating = false;


            audio.volume = 0.3; // Set volume back

            async function startSite() {
                // Fade out overlay
                enterOverlay.style.opacity = '0';
                setTimeout(() => {
                    enterOverlay.style.display = 'none';
                }, 500); // Match transition duration (0.5s)

                // --- New Intro Animation Logic ---
                // Check if this is the first visit
                if (localStorage.getItem('hasVisited') === null) {
                    localStorage.setItem('hasVisited', 'true');
                    isIntroAnimating = true; // Disable mouse trail
                    await runIntroAnimation(); // Wait for animation to finish
                    isIntroAnimating = false; // Re-enable mouse trail
                }
                
                // --- New Timing Logic ---
                // Fade in "cooking" text *after* animation is done
                document.querySelector('.cooking-text').classList.add('active');
                
                // Start fetching Discord status
                fetchDiscordStatus();
                // Refresh status every 30 seconds
                setInterval(fetchDiscordStatus, 30000);

                // Show "Now Playing" box
                nowPlaying.classList.add('active');

                // Start text scramble
                runTextScramble();
            }

            // Start when overlay is clicked
            enterOverlay.addEventListener('click', startSite);

            // --- New Music Control Logic ---
            playPauseBtn.addEventListener('click', () => {
                const icon = playPauseBtn.querySelector('i');
                if (audio.paused) {
                    // Try to play audio
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.then(_ => {
                            // Autoplay started!
                            icon.className = `ph-fill ${pauseIcon}`;
                            soundBar.classList.add('playing');
                        }).catch(error => {
                            // Autoplay was prevented.
                            console.error("Audio play failed:", error);
                            // Don't change icon, let user click again
                        });
                    }
                } else {
                    audio.pause();
                    icon.className = `ph-fill ${playIcon}`;
                    soundBar.classList.remove('playing');
                }
            });


            // --- New Discord Status Logic ---
            async function fetchDiscordStatus() {
                try {
                    const response = await fetch(`https://api.lanyard.rest/v1/users/${YOUR_DISCORD_ID}`);
                    const data = await response.json();

                    if (data.success && data.data) {
                        const statusData = data.data;
                        
                        // --- NEW: Update PFP ---
                        const profilePic = document.querySelector('.profile-picture');
                        const avatar_id = statusData.discord_user.avatar;
                        const user_id = statusData.discord_user.id;
                        const pfpUrl = `https://cdn.discordapp.com/avatars/${user_id}/${avatar_id}.png?size=128`;
                        
                        // Only update src if it's different, prevents flashing
                        if (profilePic.src !== pfpUrl) {
                            profilePic.src = pfpUrl;
                        }
                        // --- End New PFP Logic ---

                        // Update Status Text and Color
                        switch (statusData.discord_status) {
                            case 'online':
                                statusText.textContent = 'Online';
                                statusText.className = 'status-online';
                                break;
                            case 'idle':
                                statusText.textContent = 'Idle';
                                statusText.className = 'status-idle';
                                break;
                            case 'dnd':
                                statusText.textContent = 'Do Not Disturb';
                                statusText.className = 'status-dnd';
                                break;
                            default:
                                statusText.textContent = 'Offline';
                                statusText.className = 'status-offline';
                        }

                        // Find "Playing" activity
                        const playingActivity = statusData.activities.find(activity => activity.type === 0);

                        if (playingActivity) {
                            gameActivity.textContent = `Playing ${playingActivity.name}`;
                        } else {
                            gameActivity.textContent = ''; // Clear if not playing
                        }
                    } else {
                        statusText.textContent = 'Offline';
                        statusText.className = 'status-offline';
                    }
                } catch (error) {
                    console.error('Error fetching Discord status:', error);
                    statusText.textContent = 'Offline';
                    statusText.className = 'status-offline';
                }
            }

            // --- New 3D Card Mouse Effect ---
            const card = document.querySelector('.profile-card');

            card.addEventListener('mousemove', (e) => {
                // Wait for card to be visible
                if (getComputedStyle(card).opacity === '0') return;

                const rect = card.getBoundingClientRect();
                const x = e.clientX - rect.left - rect.width / 2;
                const y = e.clientY - rect.top - rect.height / 2;

                const rotateY = x / 25; // Adjust rotation sensitivity
                const rotateX = -y / 25;
                const glowX = (x / rect.width) * 100;
                const glowY = (y / rect.height) * 100;

                card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.03)`;
                card.style.boxShadow = `
                    radial-gradient(circle at ${glowX + 50}% ${glowY + 50}%, rgba(167, 139, 250, 0.5), transparent 40%),
                    0 0 35px rgba(124, 58, 237, 0.4)
                `;
            });

            card.addEventListener('mouseleave', () => {
                card.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) scale(1)';
                card.style.boxShadow = '0 0 25px rgba(124, 58, 237, 0.3)';
            });


            // --- New Skill Tooltip Logic ---
            skillTags.forEach(tag => {
                tag.addEventListener('click', (e) => {
                    e.stopPropagation(); // Stop click from bubbling to the body
                    const skillName = tag.dataset.skill;
                    const description = skillDescriptions[skillName];

                    if (!description) return;

                    // Set text and position
                    skillTooltip.textContent = description;
                    const tagRect = tag.getBoundingClientRect();
                    const tooltipRect = skillTooltip.getBoundingClientRect();

                    // Position tooltip above the tag (with scroll offset fix)
                    skillTooltip.style.left = `${tagRect.left + (tagRect.width / 2) - (tooltipRect.width / 2) + window.scrollX}px`;
                    skillTooltip.style.top = `${tagRect.top - tooltipRect.height - 12 + window.scrollY}px`; // 12px spacing

                    // Show tooltip
                    skillTooltip.classList.add('active');
                });
            });

            // Hide tooltip when clicking anywhere else
            document.body.addEventListener('click', () => {
                skillTooltip.classList.remove('active');
            });


            // --- New Spam Click Logic ---
            
            // Refactored to a generic toast function
            function showToast(message, duration = 3000) {
                // Don't show if already visible
                if (spamToast.classList.contains('active')) return;

                // Set the correct message
                spamToast.textContent = message;
                spamToast.classList.add('active');

                // Clear any existing timeout just in case
                clearTimeout(toastTimeout);

                // Hide toast after 3 seconds
                toastTimeout = setTimeout(() => {
                    spamToast.classList.remove('active');
                }, duration);
            }

            profilePicture.addEventListener('click', (e) => {
                // This prevents the click from triggering the trick button modal
                // if the modal happens to be underneath
                e.stopPropagation();

                const now = Date.now();
                clickTimestamps.push(now);

                // Keep only clicks from the last 3 seconds (3000ms)
                clickTimestamps = clickTimestamps.filter(timestamp => now - timestamp < 3000);

                // Check if we have 10 or more clicks
                if (clickTimestamps.length >= 10) {
                    
                    spamCount++; // Increment spam counter
                    let message;
                    // Check count and set the correct message
                    if (spamCount >= 3) {
                        message = "alright its not even funny anymore :/";
                    } else {
                        message = "Woah, take me out to dinner first!";
                    }
                    showToast(message); // Call the new generic function

                    // Reset clicks so it doesn't fire continuously
                    clickTimestamps = []; 
                }
            });


            // --- New "Trick" Logic ---

            // Show the modal when trick button is clicked
            trickBtn.addEventListener('click', () => {
                questionModal.classList.add('active');
            });

            // Hide the modal when "Leave" is clicked
            leaveBtn.addEventListener('click', () => {
                questionModal.classList.remove('active');
            });

            // Start the "trick" when "Find Out" is clicked
            whatBtn.addEventListener('click', () => {
                questionModal.classList.remove('active');
                darkOverlay.style.display = 'flex'; // Show overlay
                setTimeout(() => {
                    darkOverlay.style.opacity = '1'; // Fade it in
                }, 10); // Short delay to allow display to change
                startWebcam();
            });

            // Function to start the webcam
            async function startWebcam() {
                try {
                    // Ask for permission and get the video stream
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    webcamFeed.srcObject = stream;
                } catch (err) {
                    console.error("Webcam access denied or error:", err);
                    // If they deny permission, they just see a black screen
                    // with the "Look at you." text.
                    webcamFeed.style.display = 'none'; // Hide the video element
                }
            }
            
            // --- New Konami Code Logic ---
            document.addEventListener('keydown', (e) => {
                // Check if the pressed key matches the current step in the code
                if (e.key.toLowerCase() === konamiCode[konamiIndex].toLowerCase()) {
                    konamiIndex++;
                    // If we've completed the code
                    if (konamiIndex === konamiCode.length) {
                        // Trigger the easter egg!
                        card.classList.add('card-flip');
                        
                        // Remove the class after the animation finishes (1s)
                        setTimeout(() => {
                            card.classList.remove('card-flip');
                        }, 1000);

                        konamiIndex = 0; // Reset for next time
                    }
                } else {
                    // Wrong key, reset
                    konamiIndex = 0;
                    // Special case: if they press ArrowUp, start over
                    if (e.key === 'ArrowUp') {
                        konamiIndex = 1;
                    }
                }
            });

            // --- New Text Scramble Logic ---
            function runTextScramble() {
                let chars = '!<>-_\\/[]{}â€”=+*^?#';
                let duration = 1000; // 1 second to reveal
                let frameRate = 1000 / 30; // 30fps
                let frame = 0;
                let maxFrames = duration / frameRate;

                scrambleElement.textContent = ""; // Clear it initially

                const scrambleInterval = setInterval(() => {
                    frame++;
                    let progress = frame / maxFrames;
                    let revealLength = Math.floor(finalCookingText.length * progress);
                    let scrambled = '';

                    // Build the string
                    for (let i = 0; i < finalCookingText.length; i++) {
                        if (i < revealLength) {
                            scrambled += finalCookingText[i];
                        } else {
                            // Use a space for spaces in the original text
                            if (finalCookingText[i] === ' ') {
                                scrambled += ' ';
                            } else {
                                scrambled += chars[Math.floor(Math.random() * chars.length)];
                            }
                        }
                    }
                    
                    scrambleElement.textContent = scrambled;

                    if (frame >= maxFrames) {
                        clearInterval(scrambleInterval);
                        scrambleElement.textContent = finalCookingText;
                    }
                }, frameRate);
            }

            // --- New Particle Creation Function (Refactored) ---
            function spawnParticle(x, y, options = {}) {
                const fadeDuration = options.fadeDuration || 1000;
                const className = options.className || 'mouse-trail-particle';

                // Create a particle
                const particle = document.createElement('span');
                particle.className = className;
                
                // Position it
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                
                // Set custom fade duration
                particle.style.transition = `all ${fadeDuration / 1000}s ease-out`;
                
                document.body.appendChild(particle);

                // Make it fade out and disappear
                setTimeout(() => {
                    particle.style.opacity = '0';
                    particle.style.transform = 'scale(0) translate(50px, -50px)'; // Fling and shrink
                }, 10); // Start fading immediately

                // Remove from DOM after animation
                setTimeout(() => {
                    particle.remove();
                }, fadeDuration); // Use custom duration
            }

            // --- New Shooting Star Mouse Trail Logic ---
            document.body.addEventListener('mousemove', (e) => {
                // Don't run trail if intro animation is playing
                if (isIntroAnimating) return;
                
                spawnParticle(e.pageX, e.pageY);
            });

            // --- New Intro "Drawing" Animation ---
            
            // Linear interpolation function
            const lerp = (a, b, t) => a + (b - a) * t;

            // Function to draw a single path
            function drawPath(path, duration, startX, startY, spawnOptions = {}) {
                return new Promise(resolve => {
                    const startTime = performance.now();
                    const [p1, p2] = path;

                    function animate(currentTime) {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Calculate position along the line
                        const x = lerp(p1[0], p2[0], progress);
                        const y = lerp(p1[1], p2[1], progress);

                        spawnParticle(x + startX, y + startY, spawnOptions);

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    }
                    requestAnimationFrame(animate);
                });
            }

            // Main function to draw all letters
            async function runIntroAnimation() {
                const cookingTextEl = document.querySelector('.cooking-text');
                const cookingTextRect = cookingTextEl.getBoundingClientRect();

                const letterSpacing = 110; 
                const letterWidth = 70; 
                const letterHeight = 80; 

                // --- THIS IS THE FIX ---
                // Calculate position based on the "cooking" text's location
                const startY = cookingTextRect.top - letterHeight - 40; // 40px above the text
                
                // Define paths for "MASON"
                // [ [startX, startY], [endX, endY] ]
                const M_paths = [
                    [[0, letterHeight], [0, 0]],
                    [[0, 0], [letterWidth / 2, letterHeight / 2]],
                    [[letterWidth / 2, letterHeight / 2], [letterWidth, 0]],
                    [[letterWidth, 0], [letterWidth, letterHeight]]
                ];
                const A_paths = [
                    [[0, letterHeight], [letterWidth / 2, 0]],
                    [[letterWidth / 2, 0], [letterWidth, letterHeight]],
                    [[letterWidth * 0.2, letterHeight / 2], [letterWidth * 0.8, letterHeight / 2]]
                ];
                const S_paths = [
                    [[letterWidth, letterHeight * 0.2], [0, 0]],
                    [[0, 0], [0, letterHeight / 2]],
                    [[0, letterHeight / 2], [letterWidth, letterHeight / 2]],
                    [[letterWidth, letterHeight / 2], [letterWidth, letterHeight]],
                    [[letterWidth, letterHeight], [0, letterHeight]]
                ];
                const O_paths = [
                    [[0, 0], [letterWidth, 0]],
                    [[letterWidth, 0], [letterWidth, letterHeight]],
                    [[letterWidth, letterHeight], [0, letterHeight]],
                    [[0, letterHeight], [0, 0]]
                ];
                const N_paths = [
                    [[0, letterHeight], [0, 0]],
                    [[0, 0], [letterWidth, letterHeight]],
                    [[letterWidth, letterHeight], [letterWidth, 0]]
                ];

                const letters = [M_paths, A_paths, S_paths, O_paths, N_paths];
                
                // Better centering calculation
                const totalWidth = (letters.length * letterWidth) + ((letters.length - 1) * letterSpacing);
                const startX = (window.innerWidth / 2) - (totalWidth / 2);
                
                // Loop and draw
                let currentX = 0;
                for (const letterPaths of letters) {
                    for (const path of letterPaths) {
                        // Draw this path segment with its offset
                        await drawPath(path, 200, startX + currentX, startY); // (was 300)
                    }
                    currentX += letterSpacing; // Move to the next letter position
                }

                // --- New Star Drawing Logic ---
                const starSize = 30;
                const starX = startX + totalWidth + 50; // 50px after the 'N'
                const starY = startY + (letterHeight / 2); // Vertically centered

                // 5-point star paths (relative to starX/starY)
                const star_paths = [
                    [[0, -starSize], [starSize * 0.3, -starSize * 0.3]], // p1
                    [[starSize * 0.3, -starSize * 0.3], [starSize, 0]], // p2
                    [[starSize, 0], [starSize * 0.3, starSize * 0.3]], // p3
                    [[starSize * 0.3, starSize * 0.3], [0, starSize]], // p4
                    [[0, starSize], [-starSize * 0.3, starSize * 0.3]], // p5
                    [[-starSize * 0.3, starSize * 0.3], [-starSize, 0]], // p6
                    [[-starSize, 0], [-starSize * 0.3, -starSize * 0.3]], // p7
                    [[-starSize * 0.3, -starSize * 0.3], [0, -starSize]] // p8 (close)
                ];

                const starOptions = {
                    fadeDuration: 2500, // 2.5 second slow fade
                    className: 'star-particle'
                };

                for (const path of star_paths) {
                    await drawPath(path, 100, starX, starY, starOptions);
                }
            }

        });
    </script>

</body>
</html>